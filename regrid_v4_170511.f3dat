;NOTE: Must regrid before the accumulated displacement equals
;       the minimum width of a zone
;       Otherwise the preservation calculations will be rendered
;       less accurate.
;       No null zones allowed in this formulation.
;       Call this file after model has been defined,but before stepping
;
;
;set echo off
;
fish define setupmem
 fssurf=memory.create(gp.num*3);xsurface,ysurface,zsurface
 pairs1=memory.create(8) 
 pairs2=memory.create(8) 
 coords=memory.create(gp.num*3)
 coords2=memory.create(gp.num*3)
 znn2zn=memory.create(zone.num)
 gpn2gp=memory.create(gp.num)
end
;
fish define repairbase
 zn=zone.head
 loop while zn#null
  if gp.pos.z(zone.gp(zn,1))=0 then
   gp1=zone.gp(zn,1) 
   gp2=zone.gp(zn,2) 
   gp3=zone.gp(zn,3) 
   gp4=zone.gp(zn,4) 
   gp5=zone.gp(zn,5) 
   gp6=zone.gp(zn,6) 
   gp7=zone.gp(zn,7) 
   gp8=zone.gp(zn,8) 
   gp.pos.x(gp1)=gp.pos.x(gp4)
   gp.pos.y(gp1)=gp.pos.y(gp4)
   gp.pos.x(gp2)=gp.pos.x(gp7)
   gp.pos.y(gp2)=gp.pos.y(gp7)
   gp.pos.x(gp3)=gp.pos.x(gp6)
   gp.pos.y(gp3)=gp.pos.y(gp6)
   gp.pos.x(gp5)=gp.pos.x(gp8)
   gp.pos.y(gp5)=gp.pos.y(gp8)
  end_if    
  zn=zone.next(zn)
 end_loop
end
;
fish define zones_gp_ct

;build zone numbering format 
 table.x(1+1,1)=2 
 table.x(1+1,2)=3
 table.x(1+1,3)=4

 table.x(2+1,1)=1
 table.x(2+1,2)=5
 table.x(2+1,3)=7
 
 table.x(3+1,1)=1
 table.x(3+1,2)=5
 table.x(3+1,3)=6
 
 table.x(4+1,1)=1
 table.x(4+1,2)=6
 table.x(4+1,3)=7
 
 table.x(5+1,1)=2
 table.x(5+1,2)=3
 table.x(5+1,3)=8
 
 table.x(6+1,1)=3
 table.x(6+1,2)=4
 table.x(6+1,3)=8
 
 table.x(7+1,1)=2
 table.x(7+1,2)=4
 table.x(7+1,3)=8
 
 table.x(8+1,1)=6
 table.x(8+1,2)=7
 table.x(8+1,3)=5

;clear mem
rgct=memory.create(gp.num*6)
loop rgi (0,gp.num*6-1)
  memory(rgct+rgi)=0
end_loop

; Build gp connection list

zn = zone.head
 loop while zn#null
  loop rgi(1,8)
   p_gp=zone.gp(zn,rgi)
   gpn=gp.id(p_gp)
   arrnum=rgct+6*(gpn+(-1))
   ;connected to gp i is ...
   p_gp=zone.gp(zn,table.x(rgi+1,1))
   gpn1=gp.id(p_gp)
   p_gp=zone.gp(zn,table.x(rgi+1,2))
   gpn2=gp.id(p_gp)
   p_gp=zone.gp(zn,table.x(rgi+1,3))
   gpn3=gp.id(p_gp)
   

   ;check connect list to see what we have so far
   rgcnt=0

    gpc=memory(arrnum+rgcnt)
    loop while gpc#0
    gpc=memory(arrnum+rgcnt)
    if gpc#0 then
     if gpn1=gpc then
      gpn1=0
     end_if
     if gpn2=gpc then
      gpn2=0
     end_if
     if gpn3=gpc then
      gpn3=0
     end_if
     rgcnt=rgcnt+1
     if rgcnt>5 then 
      gpc=0
     end_if
    end_if
   end_loop
   
   ;append connect list

   if gpn1#0 then
    memory(arrnum+rgcnt)=gpn1
    rgcnt=rgcnt+1
   end_if

   if gpn2#0 then
    memory(arrnum+rgcnt)=gpn2
    rgcnt=rgcnt+1
   end_if

   if gpn3#0 then
    memory(arrnum+rgcnt)=gpn3
   end_if

  end_loop
  zn=zone.next(zn)
 
 end_loop


;Zone IDs to Zone Ptrs
 zn=zone.head
 loop while zn#null
  znn=zone.id(zn)-1
  memory(znn2zn+znn)=zn
  zn=zone.next(zn)
 end_loop

;GP IDs to GP Ptrs
 gp=gp.head
 loop while gp#null
  gpn=gp.id(gp)-1
  memory(gpn2gp+gpn)=gp
  gp=gp.next(gp)
 end_loop


;finds zones around each gp
zgm=memory.create(6*gp.num)
loop zgi(0,6*gp.num-1)
 memory(zgm+zgi)=0
end_loop

zn=zone.head
loop while zn#null
 znn=zone.id(zn)
 loop zgi(1,8)
  gp=zone.gp(zn,zgi)
  gpn=gp.id(gp)
  gparr=(gpn-1)*6
  ;check to see if we already have this zone
  zgj=0
  znval=1
  gotflg=0
  loop while znval#0
   znval=memory(zgm+gparr+zgj)
   if znval=znn then
    gotflg=1
   end_if
   zgj=zgj+1
   if zgj=6 then 
    znval=0
   end_if
  end_loop
  zgj=zgj-1
  if gotflg=0 then
   memory(zgm+gparr+zgj)=znn
  end_if
 end_loop
 zn=zone.next(zn)
end_loop

;find zones around each zone, including the centre zone
 zzm=memory.create(27*gp.num)
 loop zgi(0,27*gp.num-1)
  memory(zzm+zgi)=0
 end_loop

 zn=zone.head
 loop while zn#null
  znn=zone.id(zn)
  znarr=(znn-1)*27
  loop zgi(1,8)
   gp=zone.gp(zn,zgi)
   gpn=gp.id(gp)
   gparr=(gpn-1)*6
   znval=1
   zgj=0
   loop while znval#0
    znval=memory(zgm+gparr+zgj)
    ; Check to see if we already have this zone
    znval2=1
    zgk=0
    gotflg=0
    loop while znval2#0
     znval2=memory(zzm+znarr+zgk)
     if znval=znval2 then
      gotflg=1
     end_if
     zgk=zgk+1
     if zgk>26 then
      znval2=0
     end_if
    end_loop
    zgk=zgk-1
    ;Add zone to zone list if we haven't got it
    if gotflg=0 then
     memory(zzm+znarr+zgk)=znval
    end_if
    zgj=zgj+1
    if zgj>5 then
     znval=0
    end_if
   end_loop
  end_loop
  zn=zone.next(zn)
 end_loop

err=memory.delete(zzm)

end
;
;
fish define findsurfaces
 ;finds the surfaces of the model - expects rectangular cross-sections

 xmin=1e10
 ymin=1e10
 zmin=1e10
 xmax=-1e10
 ymax=-1e10
 zmax=-1e10

;find max-min
 gp=gp.head
 loop while gp#null

  if gp.pos.x(gp)<xmin then
   xmin=gp.pos.x(gp)
  end_if
  if gp.pos.y(gp)<ymin then
   ymin=gp.pos.y(gp)
  end_if
  if gp.pos.z(gp)<zmin then
   zmin=gp.pos.z(gp)
  end_if

 if gp.pos.x(gp)>xmax then
   xmax=gp.pos.x(gp)
  end_if
 if gp.pos.y(gp)>ymax then
   ymax=gp.pos.y(gp)
  end_if
 if gp.pos.z(gp)>zmax then
   zmax=gp.pos.z(gp)
  end_if
 gp=gp.next(gp)
 end_loop

;set up tables

 gp=gp.head
 loop while gp#null
  gpnum=gp.id(gp)
  fsarr=(gpnum-1)*3

  memory(fssurf+fsarr)=0
  memory(fssurf+fsarr+1)=0
  memory(fssurf+fsarr+2)=0

  if gp.pos.x(gp)=xmin then
   memory(fssurf+fsarr)=-1
  end_if
  if gp.pos.y(gp)=ymin then
   memory(fssurf+fsarr+1)=-1
  end_if
  
  if gp.pos.x(gp)=xmax then
   memory(fssurf+fsarr)=1
  end_if
  if gp.pos.y(gp)=ymax then
   memory(fssurf+fsarr+1)=1
  end_if
  if gp.pos.z(gp)=zmax then
   memory(fssurf+fsarr+2)=1
  end_if
  
  if gp.pos.z(gp)=zmin then
   memory(fssurf+fsarr+2)=-1
  end_if

  gp=gp.next(gp)
 end_loop

end
;
;
fish define regrid
;Regrids by changing gridpoints to points where they are more inline with 
; homogeneous strain
;ie two sets of parallel edges


memory(pairs1)=1
memory(pairs1+1)=2
memory(pairs1+2)=4
memory(pairs1+3)=7
memory(pairs1+4)=6
memory(pairs1+5)=8
memory(pairs1+6)=3
memory(pairs1+7)=5

memory(pairs2)=1
memory(pairs2+1)=3
memory(pairs2+2)=4
memory(pairs2+3)=6
memory(pairs2+4)=7
memory(pairs2+5)=8
memory(pairs2+6)=2
memory(pairs2+7)=5

;backup coords
gp11=gp.head
loop while gp11#null
 gpn=gp.id(gp11)
 crdarr=(gpn-1)*3
 memory(coords2+crdarr)=gp.pos.x(gp11)
 memory(coords2+crdarr+1)=gp.pos.y(gp11)
 memory(coords2+crdarr+2)=gp.pos.z(gp11)
 gp11=gp.next(gp11)
end_loop


 loop masterl (1,mloop)

repairbase
  
;backup coords
gp11=gp.head
loop while gp11#null
 gpn=gp.id(gp11)
 crdarr=(gpn-1)*3
 memory(coords+crdarr)=gp.pos.x(gp11)
 memory(coords+crdarr+1)=gp.pos.y(gp11)
 memory(coords+crdarr+2)=gp.pos.z(gp11)
 gp11=gp.next(gp11)
end_loop
  
  
  
  strout=string(masterl)
  err=io.out(strout)
  p_z=zone.head
  loop while p_z#null
   vxav1=0
   vyav1=0
   vzav1=0
   vxav2=0
   vyav2=0
   vzav2=0
   loop rgi(0,3)
    
    rgpt=rgi*2
    pt1=memory(pairs1+rgpt)
    pt2=memory(pairs1+rgpt+1)
    pt3=memory(pairs2+rgpt)
    pt4=memory(pairs2+rgpt+1)
  
    zb1=zone.gp(p_z,pt1)
    zb2=zone.gp(p_z,pt2)
    
    gpn1=gp.id(zb1)
    gpn2=gp.id(zb2)
    crdarr=(gpn1-1)*3
    xpo1=memory(coords+crdarr)
    ypo1=memory(coords+crdarr+1)
    zpo1=memory(coords+crdarr+2)
    crdarr=(gpn2-1)*3
    xpo2=memory(coords+crdarr)
    ypo2=memory(coords+crdarr+1)
    zpo2=memory(coords+crdarr+2)
    
    vxav1=vxav1+xpo1-xpo2
    vyav1=vyav1+ypo1-ypo2
    vzav1=vzav1+zpo1-zpo2
    
    zb3=zone.gp(p_z,pt3)
    zb4=zone.gp(p_z,pt4)
    
    gpn3=gp.id(zb3)
    gpn4=gp.id(zb4)
    crdarr=(gpn3-1)*3
    xpo3=memory(coords+crdarr)
    ypo3=memory(coords+crdarr+1)
    zpo3=memory(coords+crdarr+2)
    crdarr=(gpn4-1)*3
    xpo4=memory(coords+crdarr)
    ypo4=memory(coords+crdarr+1)
    zpo4=memory(coords+crdarr+2)
    vxav2=vxav2+xpo3-xpo4
    vyav2=vyav2+ypo3-ypo4
    vzav2=vzav2+zpo3-zpo4
   end_loop
   vxav1=vxav1/4
   vyav1=vyav1/4
   vzav1=vzav1/4
   vxav2=vxav2/4
   vyav2=vyav2/4
   vzav2=vzav2/4
   
   loop rgi(0,3)
    rgpt=rgi*2
    pt1=memory(pairs1+rgpt)
    pt2=memory(pairs1+rgpt+1)
    pt3=memory(pairs2+rgpt)
    pt4=memory(pairs2+rgpt+1)
    
    zb1=zone.gp(p_z,pt1)
    zb2=zone.gp(p_z,pt2)
    zb3=zone.gp(p_z,pt3)
    zb4=zone.gp(p_z,pt4)
    
    gpn1=gp.id(zb1)-1
    gpn2=gp.id(zb2)-1
    gpn3=gp.id(zb3)-1
    gpn4=gp.id(zb4)-1
    
    crdarr=(gpn1)*3
    xpo1=memory(coords+crdarr)
    ypo1=memory(coords+crdarr+1)
    zpo1=memory(coords+crdarr+2)
    crdarr=(gpn2)*3
    xpo2=memory(coords+crdarr)
    ypo2=memory(coords+crdarr+1)
    zpo2=memory(coords+crdarr+2)
    crdarr=(gpn3)*3
    xpo3=memory(coords+crdarr)
    ypo3=memory(coords+crdarr+1)
    zpo3=memory(coords+crdarr+2)
    crdarr=(gpn4)*3
    xpo4=memory(coords+crdarr)
    ypo4=memory(coords+crdarr+1)
    zpo4=memory(coords+crdarr+2)


    vxch=(vxav1-(xpo1-xpo2))/divby 

    
    fsarr=gpn1*3
    if memory(fssurf+fsarr)=0 then
     gp.pos.x(zb1)=gp.pos.x(zb1)+vxch
    end_if

    fsarr=gpn2*3
    if memory(fssurf+fsarr)=0 then
     gp.pos.x(zb2)=gp.pos.x(zb2)-vxch
    end_if
    
    vych=(vyav1-(ypo1-ypo2))/divby 
    
    fsarr=gpn1*3+1
    if memory(fssurf+fsarr)=0 then
     gp.pos.y(zb1)=gp.pos.y(zb1)+vych
    end_if
    
    fsarr=gpn2*3+1
    if memory(fssurf+fsarr)=0 then
     gp.pos.y(zb2)=gp.pos.y(zb2)-vych
    end_if
    
    vzch=(vzav1-(zpo1-zpo2))/divby 
    
    fsarr=gpn1*3+2
    if memory(fssurf+fsarr)=0 then
     if gp.pos.z(zb1)=0 then
      err=io.in('Error')
     end_if
     gp.pos.z(zb1)=gp.pos.z(zb1)+vzch
    end_if
    
    fsarr=gpn2*3+2
    if memory(fssurf+fsarr)=0 then
     if gp.pos.z(zb2)=0 then
      err=io.in('Error')
     end_if
     gp.pos.z(zb2)=gp.pos.z(zb2)-vzch
    end_if

vxchb=vxch
vychb=vych
vzchb=vzch
    
    vxch=(vxav2-(xpo3-xpo4))/divby 
    
    fsarr=gpn3*3
    if memory(fssurf+fsarr)=0 then
     gp.pos.x(zb3)=gp.pos.x(zb3)+vxch
    end_if
    
    fsarr=gpn4*3
    if memory(fssurf+fsarr)=0 then
     gp.pos.x(zb4)=gp.pos.x(zb4)-vxch
    end_if

    vych=(vyav2-(ypo3-ypo4))/divby 
    
    fsarr=gpn3*3+1
    if memory(fssurf+fsarr)=0 then
     gp.pos.y(zb3)=gp.pos.y(zb3)+vych
    end_if

    fsarr=gpn4*3+1
    if memory(fssurf+fsarr)=0 then
     gp.pos.y(zb4)=gp.pos.y(zb4)-vych
    end_if

    vzch=(vzav2-(zpo3-zpo4))/divby 
    
    fsarr=gpn3*3+2
    if memory(fssurf+fsarr)=0 then
     gp.pos.z(zb3)=gp.pos.z(zb3)+vzch
    end_if

    fsarr=gpn4*3+2
    if memory(fssurf+fsarr)=0 then
     gp.pos.z(zb4)=gp.pos.z(zb4)-vzch
    end_if    

   
   end_loop
   p_z=zone.next(p_z)
  end_loop
 
 maxch=0
 gp=gp.head
 loop while gp#null
  gpn=gp.id(gp)
  xpn=gp.pos.x(gp)
  ypn=gp.pos.y(gp)
  zpn=gp.pos.z(gp)
  crdarr=(gpn-1)*3
  xpo=memory(coords+crdarr)
  ypo=memory(coords+crdarr+1)
  zpo=memory(coords+crdarr+2)
  rng=(xpo-xpn)^2+(ypo-ypn)^2+(zpo-zpn)^2
  if rng>maxch then 
   maxch=rng
  end_if
  gp=gp.next(gp)
 end_loop
 maxch=math.sqrt(maxch)
 err=io.out('Max change this step')
 command
    list @maxch
 end_command
 end_loop;master loop

;Preserve surface topography
gp22=gp.head 
loop while gp22#null
 gpn=gp.id(gp22)
 fsarr=(gpn-1)*3
 if memory(fssurf+fsarr+2)#0 then
  if gp.pos.z(gp22)#0 then
   zn=zone.near(gp.pos.x(gp22)+0.1,gp.pos.y(gp22),gp.pos.z(gp22))
   gp4=zone.gp(zn,4)
   gp7=zone.gp(zn,7)
   gp6=zone.gp(zn,6)
   gp8=zone.gp(zn,8)
   gpn4=gp.id(gp4)
   gpn7=gp.id(gp7)
   gpn6=gp.id(gp6)
   gpn8=gp.id(gp8)
   
   gparr=(gpn-1)*3
   oldx=memory(coords2+gparr)
   oldy=memory(coords2+gparr+1)
   oldz=memory(coords2+gparr+2)
   
   gparr=(gpn4-1)*3
   oldx4=memory(coords2+gparr)
   oldy4=memory(coords2+gparr+1)
   oldz4=memory(coords2+gparr+2)
   gparr=(gpn7-1)*3
   oldx7=memory(coords2+gparr)
   oldy7=memory(coords2+gparr+1)
   oldz7=memory(coords2+gparr+2)
   gparr=(gpn6-1)*3
   oldx6=memory(coords2+gparr)
   oldy6=memory(coords2+gparr+1)
   oldz6=memory(coords2+gparr+2)
   gparr=(gpn8-1)*3
   oldx8=memory(coords2+gparr)
   oldy8=memory(coords2+gparr+1)
   oldz8=memory(coords2+gparr+2)

   chngzx=(oldz7+oldz8-oldz4-oldz6)
   chngzx=chngzx/(oldx7+oldx8-oldx4-oldx6)
   chngzy=(oldz6+oldz8-oldz4-oldz7)
   chngzy=chngzy/(oldy6+oldy8-oldy4-oldy7)

   xcg=gp.pos.x(gp22)-oldx
   ycg=gp.pos.y(gp22)-oldy
   chz=chngzx*xcg+chngzy*ycg
   
   gp.pos.z(gp22)=gp.pos.z(gp22)+chz
  end_if
 end_if
 gp22=gp.next(gp22)
end_loop 

;preserve velocities and displacements
maxch=0

xvm=memory.create(gp.num)
yvm=memory.create(gp.num)
zvm=memory.create(gp.num)
xdm=memory.create(gp.num)
ydm=memory.create(gp.num)
zdm=memory.create(gp.num)

gp33=gp.head
loop while gp33#null
 xpn=gp.pos.x(gp33)
 ypn=gp.pos.y(gp33)
 zpn=gp.pos.z(gp33)
 xtot=0
 ytot=0
 ztot=0
 xdtot=0
 ydtot=0
 zdtot=0
 alltot=0

 gpn=gp.id(gp33)
 gparr=(gpn-1)*6
 gpn2=1
 rgl=0
 endflg=0

 loop while gpn2#0 
  gpn2=memory(gparr+rgct+rgl)
  if gpn2=0 then
   gpn2=gpn
   endflg=1
   ;ie do the calculation for gp33 too
  end_if

  crdarr=(gpn2-1)*3
  xpo=memory(coords2+crdarr)
  ypo=memory(coords2+crdarr+1)
  zpo=memory(coords2+crdarr+2)
  rng=math.sqrt((xpo-xpn)^2+(ypo-ypn)^2+(zpo-zpn)^2)+1e-8
  gp2=memory(gpn2gp+gpn2-1)
  xtot=xtot+gp.vel.x(gp2)/rng
  ytot=ytot+gp.vel.y(gp2)/rng
  ztot=ztot+gp.vel.z(gp2)/rng
  xdtot=xdtot+gp.disp.x(gp2)/rng
  ydtot=ydtot+gp.disp.y(gp2)/rng
  zdtot=zdtot+gp.disp.z(gp2)/rng
  alltot=alltot+1/rng
  rgl=rgl+1
  if rgl>5 then 
   gpn2=0
  end_if
  if endflg#0 then
   if rng>maxch then
    maxch=rng
   end_if
   gpn2=0
  end_if
 end_loop

 memory(xvm+gpn-1)=xtot/alltot
 memory(yvm+gpn-1)=ytot/alltot
 memory(zvm+gpn-1)=ztot/alltot
 memory(xdm+gpn-1)=xdtot/alltot
 memory(ydm+gpn-1)=ydtot/alltot
 memory(zdm+gpn-1)=zdtot/alltot
 gp33=gp.next(gp33)
end_loop

err=io.out('Max total change')
command
  list @maxch
end_command

;copy back vels and disps
gp44=gp.head
loop while gp44#null
 gpn=gp.id(gp44)
 
 fsarr=(gpn-1)*3
 if memory(fssurf+fsarr)=0 then
  gp.vel.x(gp44)=memory(xvm+gpn-1)
 end_if
 
 if memory(fssurf+fsarr+1)=0 then
  gp.vel.y(gp44)=memory(yvm+gpn-1)
 end_if
 
 if memory(fssurf+fsarr+2)=0 then
  gp.vel.z(gp44)=memory(zvm+gpn-1)
 end_if
 
 if memory(fssurf+fsarr+2)=1 then
  gp.vel.z(gp44)=memory(zvm+gpn-1)
 end_if
 

 if memory(fssurf+fsarr)=0 then
  gp.disp.x(gp44)=memory(xdm+gpn-1)
 end_if
 
 if memory(fssurf+fsarr+1)=0 then
  gp.disp.y(gp44)=memory(ydm+gpn-1)
 end_if
 
 if memory(fssurf+fsarr+2)=0 then
  gp.disp.z(gp44)=memory(zdm+gpn-1)
 end_if
 
 if memory(fssurf+fsarr+2)=1 then
  gp.disp.z(gp44)=memory(zdm+gpn-1)
 end_if
 
 gp44=gp.next(gp44)
end_loop

err=memory.delete(xvm)
err=memory.delete(yvm)
err=memory.delete(zvm)
err=memory.delete(xdm)
err=memory.delete(ydm)
err=memory.delete(zdm)



;preserve zone stresses
 sxxm=memory.create(zone.num)
 sxym=memory.create(zone.num)
 sxzm=memory.create(zone.num)
 syym=memory.create(zone.num)
 syzm=memory.create(zone.num)
 szzm=memory.create(zone.num)


zn=zone.head
loop while zn#null
 midptx=0
 midpty=0
 midptz=0
 loop rgi(1,8)
  midptx=midptx+gp.pos.x(zone.gp(zn,rgi))
  midpty=midpty+gp.pos.y(zone.gp(zn,rgi))
  midptz=midptz+gp.pos.z(zone.gp(zn,rgi))
 end_loop
 midptx=midptx/8
 midpty=midpty/8
 midptz=midptz/8

 sxxtot=0
 sxytot=0
 sxztot=0
 syytot=0
 syztot=0
 szztot=0
 alltot=0

 znn=zone.id(zn) 
 

 znarr=(znn-1)*27
 znn2=1
 zni=0

 loop while znn2#0
  znn2=memory(zzm+znarr+zni)
  
  if znn2#0 then
   zn2=memory(znn2zn+znn2-1)
   oldmx=0
   oldmy=0
   oldmz=0
   loop rgi(1,8)
    gp2=zone.gp(zn2,rgi)
    gpn=gp.id(gp2)
    crdarr=(gpn-1)*3
    xpo=memory(coords2+crdarr)
    ypo=memory(coords2+crdarr+1)
    zpo=memory(coords2+crdarr+2)
    oldmx=oldmx+xpo
    oldmy=oldmy+ypo
    oldmz=oldmz+zpo
   end_loop
   oldmx=oldmx/8
   oldmy=oldmy/8
   oldmz=oldmz/8

   rng=math.sqrt((oldmx-midptx)^2+(oldmy-midpty)^2+(oldmz-midptz)^2)+1e-8
   sxxtot=sxxtot+zone.stress.xx(zn2)/rng
   sxxbfr=zone.stress.xx(zn2)/rng
   sxxbf= zone.stress.xx(zn2)
   sxytot=sxytot+zone.stress.xy(zn2)/rng
   sxztot=sxztot+zone.stress.xz(zn2)/rng
   syytot=syytot+zone.stress.yy(zn2)/rng
   syztot=syztot+zone.stress.yz(zn2)/rng
   szztot=szztot+zone.stress.zz(zn2)/rng
   alltot=alltot+1/rng
   
  end_if
  zni=zni+1
  if zni>26 then 
   znn2=0
  end_if
 end_loop 
 memory(sxxm+znn-1)=sxxtot/alltot
 memory(sxym+znn-1)=sxytot/alltot
 memory(sxzm+znn-1)=sxztot/alltot
 memory(syym+znn-1)=syytot/alltot
 memory(syzm+znn-1)=syztot/alltot
 memory(szzm+znn-1)=szztot/alltot

 zn=zone.next(zn)
end_loop 
zn=zone.head
loop while zn#null
 znn=zone.id(zn)
 zone.stress.xx(zn)=memory(sxxm+znn-1)
 zone.stress.xy(zn)=memory(sxym+znn-1)
 zone.stress.xz(zn)=memory(sxzm+znn-1)
 zone.stress.yy(zn)=memory(syym+znn-1)
 zone.stress.yz(zn)=memory(syzm+znn-1)
 zone.stress.zz(zn)=memory(szzm+znn-1)
 zn=zone.next(zn)
end_loop

err=memory.delete(sxxm)
err=memory.delete(sxym)
err=memory.delete(sxzm)
err=memory.delete(syym)
err=memory.delete(syzm)
err=memory.delete(szzm)

end
;
@setupmem
;
list @rgct
;
@zones_gp_ct
;
@findsurfaces
;
fish set @divby 20 ;the diffusion coefficient => the larger the more stable and slower 
fish set @mloop 10 ;the number of regrid iterations